<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>AUKit</h1>



<h2>Contents</h2>
<ul>
<li><a href="#Fields">Fields</a></li>
<li><a href="#Audio">Audio </a></li>
<li><a href="#aukit">aukit </a></li>
<li><a href="#aukit_stream">aukit.stream </a></li>
<li><a href="#aukit_effects">aukit.effects </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>aukit</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>aukit</code></h1>
<p>AUKit: Audio decoding and processing framework for ComputerCraft
<p> AUKit is a framework designed to simplify the process of loading, modifying,
 and playing audio files in various formats.</p>
<p> It includes support for loading
 audio from many sources, including PCM, DFPWM, G.711, and ADPCM codecs, as
 well as WAV, AIFF, AU, and FLAC files. It can also generate audio on-the-fly
 as tones, noise, or silence.
<p> AUKit uses a structure called Audio to store information about each audio
 chunk. An audio object holds the sample rate of the audio, as well as the
 data for each channel stored as floating-point numbers. Audio objects can
 hold any number of channels at any sample rate with any duration.
<p> To obtain an audio object, you can use any of the main functions in the aukit
 module. These allow loading from various raw codecs or file formats, with
 data sources as strings, or tables if using a raw codec loader.
<p> Once the audio is loaded, various basic operations are available. A subset of
 the string library is available to simplify operations on the audio, and a
 number of operators (+, *, .., #) are overridden as well. There's also built-
 in functions for resampling the audio, with nearest-neighbor, linear, cubic,
 and sinc interpolation available; as well as mixing channels (including down to
 mono) and combining/splitting channels. Finally, audio objects can be exported
 back to PCM, DFPWM, or WAV data, allowing changes to be easily stored on disk.
 The stream function also automatically chunks data for use with a speaker.
 All of these functions return a new audio object, leaving the original intact.
<p> There are also a number of effects available for audio. These are contained
 in the aukit.effects table, and modify the audio passed to them (as well as
 returning the audio for streamlining). The effects are intended to speed up
 common operations on audio. More effects may be added in future versions.
<p> For simple audio playback tasks, the aukit.stream table provides a number of
 functions that can quickly decode audio for real-time playback. Each function
 returns an iterator function that can be called multiple times to obtain fully
 decoded chunks of audio in 8-bit PCM, ready for playback to one or more
 speakers. The functions decode the data, resample it to 48 kHz (using the
 default resampling method), apply a low-pass filter to decrease interpolation
 error, mix to mono if desired, and then return a list of tables with samples
 in the range [-128, 127], plus the current position of the audio. The
 iterators can be passed directly to the aukit.play function, which complements
 the aukit.stream suite by playing the decoded audio on speakers while decoding
 it in real-time, handling synchronization of speakers as best as possible.
<p> If you're really lazy, you can also call `aukit` as a function, which takes
 the path to a file, and plays this on all available speakers.
<p> Be aware that processing large amounts of audio (especially loading FLAC or
 resampling with higher quality) is *very* slow. It's recommended to use audio
 files with lower data size (8-bit mono PCM/WAV/AIFF is ideal), and potentially
 a lower sample rate, to reduce the load on the system - especially as all
 data gets converted to 8-bit DFPWM data on playback anyway. The code yields
 internally when things take a long time to avoid abort timeouts.
<p> For an example of how to use AUKit, see the accompanying auplay.lua file.
</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>License</strong>:  MIT
<p> <style>#content {width: unset !important;}</style>
</li>
        <li><strong>Author</strong>: JackMacWindows</li>
    </ul>


<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#_VERSION">_VERSION</a></td>
	<td class="summary"></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#defaultInterpolation">defaultInterpolation</a></td>
	<td class="summary"></td>
	</tr>
</table>
<h2><a href="#Audio">Audio </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#Audio.sampleRate">Audio.sampleRate</a></td>
	<td class="summary"></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio.metadata">Audio.metadata</a></td>
	<td class="summary"></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio.info">Audio.info</a></td>
	<td class="summary"></td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:len">Audio:len ()</a></td>
	<td class="summary">Returns the length of the audio object in seconds.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:channels">Audio:channels ()</a></td>
	<td class="summary">Returns the number of channels in the audio object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:resample">Audio:resample (sampleRate, interpolation)</a></td>
	<td class="summary">Creates a new audio object with the data resampled to a different sample rate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:mono">Audio:mono ()</a></td>
	<td class="summary">Mixes down all channels to a new mono-channel audio object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:concat">Audio:concat (...)</a></td>
	<td class="summary">Concatenates this audio object with another, adding the contents of each
 new channel to the end of each old channel, resampling the new channels to match
 this one (if necessary), and inserting silence in any missing channels.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:sub">Audio:sub (start, last)</a></td>
	<td class="summary">Takes a subregion of the audio and returns a new audio object with its contents.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:combine">Audio:combine (...)</a></td>
	<td class="summary">Combines the channels of this audio object with another, adding the new
 channels on the end of the new object, resampling the new channels to match
 this one (if necessary), and extending any channels that are shorter than the
 longest channel with zeroes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:split">Audio:split (...)</a></td>
	<td class="summary">Splits this audio object into one or more objects with the specified channels.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:mix">Audio:mix (amplifier, ...)</a></td>
	<td class="summary">Mixes two or more audio objects into a single object, amplifying each sample
 with a multiplier (before clipping) if desired, and clipping any values
 outside the audio range ([-1, 1]).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:rep">Audio:rep (count)</a></td>
	<td class="summary">Returns a new audio object that repeats this audio a number of times.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:reverse">Audio:reverse ()</a></td>
	<td class="summary">Returns a reversed version of this audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:pcm">Audio:pcm (bitDepth, dataType, interleaved)</a></td>
	<td class="summary">Converts the audio data to raw PCM samples.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:stream">Audio:stream (chunkSize, bitDepth, dataType)</a></td>
	<td class="summary">Returns a function that can be called to encode PCM samples in chunks.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:wav">Audio:wav (bitDepth)</a></td>
	<td class="summary">Coverts the audio data to a WAV file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Audio:dfpwm">Audio:dfpwm (interleaved)</a></td>
	<td class="summary">Converts the audio data to DFPWM.</td>
	</tr>
</table>
<h2><a href="#aukit">aukit </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#pcm">pcm (data, bitDepth, dataType, channels, sampleRate, interleaved, bigEndian)</a></td>
	<td class="summary">Creates a new audio object from the specified raw PCM data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#adpcm">adpcm (data, channels, sampleRate, topFirst, interleaved, predictor, step_index)</a></td>
	<td class="summary">Creates a new audio object from IMA ADPCM data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#msadpcm">msadpcm (data, blockAlign, channels, sampleRate, coefficients)</a></td>
	<td class="summary">Creates a new audio object from Microsoft ADPCM data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#g711">g711 (data, ulaw, channels, sampleRate)</a></td>
	<td class="summary">Creates a new audio object from G.711 u-law/A-law data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#dfpwm">dfpwm (data, channels, sampleRate)</a></td>
	<td class="summary">Creates a new audio object from DFPWM1a data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#mdfpwm">mdfpwm (data)</a></td>
	<td class="summary">Creates a new audio object from MDFPWMv3 data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wav">wav (data)</a></td>
	<td class="summary">Creates a new audio object from a WAV file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aiff">aiff (data)</a></td>
	<td class="summary">Creates a new audio object from an AIFF or AIFC file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#au">au (data)</a></td>
	<td class="summary">Creates a new audio object from an AU file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#flac">flac (data)</a></td>
	<td class="summary">Creates a new audio object from a FLAC file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new">new (duration, channels, sampleRate)</a></td>
	<td class="summary">Creates a new empty audio object with the specified duration.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#tone">tone (frequency, duration, amplitude, waveType, duty, channels, sampleRate)</a></td>
	<td class="summary">Creates a new audio object with a tone of the specified frequency and duration.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#noise">noise (duration, amplitude, channels, sampleRate)</a></td>
	<td class="summary">Creates a new audio object with white noise for the specified duration.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#pack">pack (data, bitDepth, dataType, bigEndian)</a></td>
	<td class="summary">Packs a table with PCM data into a string using the specified data type.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#play">play (callback, progress, volume, ...)</a></td>
	<td class="summary">Plays back stream functions created by one of the <a href="index.html#Audio:stream">aukit.stream</a> functions
 or <a href="index.html#Audio:stream">Audio:stream</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#detect">detect (data)</a></td>
	<td class="summary">Detect the type of audio file from the specified data.</td>
	</tr>
</table>
<h2><a href="#aukit_stream">aukit.stream </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.pcm">aukit.stream.pcm (data, bitDepth, dataType, channels, sampleRate, bigEndian, mono)</a></td>
	<td class="summary">Returns an iterator to stream raw PCM audio in CC format.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.dfpwm">aukit.stream.dfpwm (data, sampleRate, channels, mono)</a></td>
	<td class="summary">Returns an iterator to stream audio from DFPWM data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.mdfpwm">aukit.stream.mdfpwm (data, mono)</a></td>
	<td class="summary">Returns an iterator to stream audio from MDFPWMv3 data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.msadpcm">aukit.stream.msadpcm (input, blockAlign, channels, sampleRate, mono, coefficients)</a></td>
	<td class="summary">Returns an iterator to stream audio from Microsoft ADPCM data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.adpcm">aukit.stream.adpcm (input, blockAlign, channels, sampleRate, mono)</a></td>
	<td class="summary">Returns an iterator to stream data from IMA ADPCM data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.g711">aukit.stream.g711 (input, ulaw, channels, sampleRate, mono)</a></td>
	<td class="summary">Returns an iterator to stream data from u-law/A-law G.711 data.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.wav">aukit.stream.wav (data, mono, ignoreHeader)</a></td>
	<td class="summary">Returns an iterator to stream audio from a WAV file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.aiff">aukit.stream.aiff (data, mono, ignoreHeader)</a></td>
	<td class="summary">Returns an iterator to stream audio from an AIFF or AIFC file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.au">aukit.stream.au (data, mono, ignoreHeader)</a></td>
	<td class="summary">Returns an iterator to stream data from an AU file.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.stream.flac">aukit.stream.flac (data, mono)</a></td>
	<td class="summary">Returns an iterator to stream data from a FLAC file.</td>
	</tr>
</table>
<h2><a href="#aukit_effects">aukit.effects </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.amplify">aukit.effects.amplify (audio, multiplier)</a></td>
	<td class="summary">Amplifies the audio by the multiplier specified.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.speed">aukit.effects.speed (audio, multiplier)</a></td>
	<td class="summary">Changes the speed and pitch of audio by a multiplier, resampling to keep the
 same sample rate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.fade">aukit.effects.fade (audio, startTime, startAmplitude, endTime, endAmplitude)</a></td>
	<td class="summary">Fades a period of music from one amplitude to another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.invert">aukit.effects.invert (audio)</a></td>
	<td class="summary">Inverts all channels in the specified audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.normalize">aukit.effects.normalize (audio, peakAmplitude, independent)</a></td>
	<td class="summary">Normalizes audio to the specified peak amplitude.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.center">aukit.effects.center (audio)</a></td>
	<td class="summary">Centers the DC offset of each channel.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.trim">aukit.effects.trim (audio, threshold)</a></td>
	<td class="summary">Trims any extra silence on either end of the specified audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.delay">aukit.effects.delay (audio, delay, multiplier)</a></td>
	<td class="summary">Adds a delay to the specified audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.echo">aukit.effects.echo (audio, delay, multiplier)</a></td>
	<td class="summary">Adds an echo to the specified audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.reverb">aukit.effects.reverb (audio, delay, decay, wetMultiplier, dryMultiplier)</a></td>
	<td class="summary">Adds reverb to the specified audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.lowpass">aukit.effects.lowpass (audio, frequency)</a></td>
	<td class="summary">Applies a low-pass filter to the specified audio.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#aukit.effects.highpass">aukit.effects.highpass (audio, frequency)</a></td>
	<td class="summary">Applies a high-pass filter to the specified audio.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Fields"></a>Fields</h2>

    <dl class="function">
    <dt>
    <a name = "_VERSION"></a>
    <strong>_VERSION</strong>
    </dt>
    <dd>



    <ul>
        <li><span class="parameter">_VERSION</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         The version of AUKit that is loaded. This follows [SemVer](https://semver.org) format.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "defaultInterpolation"></a>
    <strong>defaultInterpolation</strong>
    </dt>
    <dd>



    <ul>
        <li><span class="parameter">defaultInterpolation</span>
            <span class="types"><span class="type">"none"</span>, <span class="type">"linear"</span>, <span class="type">"cubic"</span> or <span class="type">"sinc"</span></span>
         Default interpolation mode for <a href="index.html#Audio:resample">Audio:resample</a> and other functions that need to resample.
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Audio"></a>Audio </h2>

    <dl class="function">
    <dt>
    <a name = "Audio.sampleRate"></a>
    <strong>Audio.sampleRate</strong>
    </dt>
    <dd>



    <ul>
        <li><span class="parameter">sampleRate</span>
            <span class="types"><span class="type">number</span></span>
         The sample rate of the audio.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "Audio.metadata"></a>
    <strong>Audio.metadata</strong>
    </dt>
    <dd>



    <ul>
        <li><span class="parameter">metadata</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         Stores any metadata read from the file if present.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "Audio.info"></a>
    <strong>Audio.info</strong>
    </dt>
    <dd>



    <ul>
        <li><span class="parameter">info</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         Stores any decoder-specific information, including `bitDepth` and `dataType`.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "Audio:len"></a>
    <strong>Audio:len ()</strong>
    </dt>
    <dd>
    Returns the length of the audio object in seconds.



    <h3>Returns:</h3>
    <ol>

        number _ The audio length
    </ol>




</dd>
    <dt>
    <a name = "Audio:channels"></a>
    <strong>Audio:channels ()</strong>
    </dt>
    <dd>
    Returns the number of channels in the audio object.



    <h3>Returns:</h3>
    <ol>

        number _ The number of channels
    </ol>




</dd>
    <dt>
    <a name = "Audio:resample"></a>
    <strong>Audio:resample (sampleRate, interpolation)</strong>
    </dt>
    <dd>
    Creates a new audio object with the data resampled to a different sample rate.
 If the target rate is the same, the object is copied without modification.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">sampleRate</span>
         number The new sample rate in Hertz
        </li>
        <li><span class="parameter">interpolation</span>
        ? "none"|"linear"|"cubic" The interpolation mode to use
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the resampled data
    </ol>




</dd>
    <dt>
    <a name = "Audio:mono"></a>
    <strong>Audio:mono ()</strong>
    </dt>
    <dd>
    Mixes down all channels to a new mono-channel audio object.



    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the audio mixed to mono
    </ol>




</dd>
    <dt>
    <a name = "Audio:concat"></a>
    <strong>Audio:concat (...)</strong>
    </dt>
    <dd>
    Concatenates this audio object with another, adding the contents of each
 new channel to the end of each old channel, resampling the new channels to match
 this one (if necessary), and inserting silence in any missing channels.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         Audio The audio objects to concatenate
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The new concatenated audio object
    </ol>




</dd>
    <dt>
    <a name = "Audio:sub"></a>
    <strong>Audio:sub (start, last)</strong>
    </dt>
    <dd>
    Takes a subregion of the audio and returns a new audio object with its contents.
 This takes the same arguments as <a href="https://www.lua.org/manual/5.1/manual.html#pdf-string.sub">string.sub</a>, but positions start at 0.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">start</span>
        ? number The start position of the audio in seconds
        </li>
        <li><span class="parameter">last</span>
        ? number The end position of the audio in seconds (0 means end of file)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The new split audio object
    </ol>




</dd>
    <dt>
    <a name = "Audio:combine"></a>
    <strong>Audio:combine (...)</strong>
    </dt>
    <dd>
    Combines the channels of this audio object with another, adding the new
 channels on the end of the new object, resampling the new channels to match
 this one (if necessary), and extending any channels that are shorter than the
 longest channel with zeroes.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         Audio The audio objects to combine with
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The new combined audio object
    </ol>




</dd>
    <dt>
    <a name = "Audio:split"></a>
    <strong>Audio:split (...)</strong>
    </dt>
    <dd>
    Splits this audio object into one or more objects with the specified channels.
 Passing a channel that doesn't exist will throw an error.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         number[] The lists of channels in each new object
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio ... The new audio objects created from the channels in each list
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example">Split a stereo track into independent mono objects

     <span class="keyword">local</span> left, right = stereo:<span class="function-name">split</span>({<span class="number">1</span>}, {<span class="number">2</span>})</pre>
    </ul>

</dd>
    <dt>
    <a name = "Audio:mix"></a>
    <strong>Audio:mix (amplifier, ...)</strong>
    </dt>
    <dd>
    Mixes two or more audio objects into a single object, amplifying each sample
 with a multiplier (before clipping) if desired, and clipping any values
 outside the audio range ([-1, 1]).  Channels that are shorter are padded with
 zeroes at the end, and non-existent channels are replaced with all zeroes.
 Any audio objects with a different sample rate are resampled to match this one.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">amplifier</span>
         number|Audio The multiplier to apply, or the first audio object
        </li>
        <li><span class="parameter">...</span>
         Audio The objects to mix with this one
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The new mixed audio object
    </ol>




</dd>
    <dt>
    <a name = "Audio:rep"></a>
    <strong>Audio:rep (count)</strong>
    </dt>
    <dd>
    Returns a new audio object that repeats this audio a number of times.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">count</span>
         number The number of times to play the audio
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The repeated audio
    </ol>




</dd>
    <dt>
    <a name = "Audio:reverse"></a>
    <strong>Audio:reverse ()</strong>
    </dt>
    <dd>
    Returns a reversed version of this audio.



    <h3>Returns:</h3>
    <ol>

        Audio _ The reversed audio
    </ol>




</dd>
    <dt>
    <a name = "Audio:pcm"></a>
    <strong>Audio:pcm (bitDepth, dataType, interleaved)</strong>
    </dt>
    <dd>
    Converts the audio data to raw PCM samples.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bitDepth</span>
        ? number The bit depth of the audio (8, 16, 24, 32)
        </li>
        <li><span class="parameter">dataType</span>
        ? "signed"|"unsigned"|"float" The type of each sample
        </li>
        <li><span class="parameter">interleaved</span>
        ? boolean Whether to interleave each channel
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        number[]|nil ... The resulting audio data
    </ol>




</dd>
    <dt>
    <a name = "Audio:stream"></a>
    <strong>Audio:stream (chunkSize, bitDepth, dataType)</strong>
    </dt>
    <dd>
    Returns a function that can be called to encode PCM samples in chunks.
 This is useful as a for iterator, and can be used with <a href="index.html#play">aukit.play</a>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">chunkSize</span>
        ? number The size of each chunk
        </li>
        <li><span class="parameter">bitDepth</span>
        ? number The bit depth of the audio (8, 16, 24, 32)
        </li>
        <li><span class="parameter">dataType</span>
        ? "signed"|"unsigned"|"float" The type of each sample
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number _ The total length of the audio in seconds</li>
    </ol>




</dd>
    <dt>
    <a name = "Audio:wav"></a>
    <strong>Audio:wav (bitDepth)</strong>
    </dt>
    <dd>
    Coverts the audio data to a WAV file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bitDepth</span>
        ? number The bit depth of the audio (1 = DFPWM, 8, 16, 24, 32)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string _ The resulting WAV file data
    </ol>




</dd>
    <dt>
    <a name = "Audio:dfpwm"></a>
    <strong>Audio:dfpwm (interleaved)</strong>
    </dt>
    <dd>
    Converts the audio data to DFPWM.  All channels share the same encoder, and
 channels are stored sequentially uninterleaved if `interleaved` is false, or
 in one interleaved string if `interleaved` is true.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">interleaved</span>
        ? boolean Whether to interleave the channels
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string ... The resulting DFPWM data for each channel (only one string
 if `interleaved` is true)
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="aukit"></a>aukit </h2>

    <dl class="function">
    <dt>
    <a name = "pcm"></a>
    <strong>pcm (data, bitDepth, dataType, channels, sampleRate, interleaved, bigEndian)</strong>
    </dt>
    <dd>
    Creates a new audio object from the specified raw PCM data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|table The audio data, either as a raw string, or a table
 of values (in the format specified by `bitDepth` and `dataType`)
        </li>
        <li><span class="parameter">bitDepth</span>
        ? number The bit depth of the audio (8, 16, 24, 32); if `dataType` is "float" then this must be 32
        </li>
        <li><span class="parameter">dataType</span>
        ? "signed"|"unsigned"|"float" The type of each sample
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">interleaved</span>
        ? boolean Whether each channel is interleaved or separate
        </li>
        <li><span class="parameter">bigEndian</span>
        ? boolean Whether the audio is big-endian or little-endian; ignored if data is a table
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object containing the specified data
    </ol>




</dd>
    <dt>
    <a name = "adpcm"></a>
    <strong>adpcm (data, channels, sampleRate, topFirst, interleaved, predictor, step_index)</strong>
    </dt>
    <dd>
    Creates a new audio object from IMA ADPCM data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|table The audio data, either as a raw string, or a table of nibbles
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">topFirst</span>
        ? boolean Whether the top nibble is the first nibble
 (true) or last (false); ignored if `data` is a table
        </li>
        <li><span class="parameter">interleaved</span>
        ? boolean Whether each channel is interleaved or separate
        </li>
        <li><span class="parameter">predictor</span>
        ? number|table The initial predictor value(s)
        </li>
        <li><span class="parameter">step_index</span>
        ? number|table The initial step index(es)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object containing the decoded data
    </ol>




</dd>
    <dt>
    <a name = "msadpcm"></a>
    <strong>msadpcm (data, blockAlign, channels, sampleRate, coefficients)</strong>
    </dt>
    <dd>
    Creates a new audio object from Microsoft ADPCM data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The audio data as a raw string
        </li>
        <li><span class="parameter">blockAlign</span>
         number The number of bytes in each block
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">coefficients</span>
        ? table Two lists of coefficients to use
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object containing the decoded data
    </ol>




</dd>
    <dt>
    <a name = "g711"></a>
    <strong>g711 (data, ulaw, channels, sampleRate)</strong>
    </dt>
    <dd>
    Creates a new audio object from G.711 u-law/A-law data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The audio data as a raw string
        </li>
        <li><span class="parameter">ulaw</span>
         boolean Whether the audio uses u-law (true) or A-law (false).
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object containing the decoded data
    </ol>




</dd>
    <dt>
    <a name = "dfpwm"></a>
    <strong>dfpwm (data, channels, sampleRate)</strong>
    </dt>
    <dd>
    Creates a new audio object from DFPWM1a data.  All channels are expected to
 share the same decoder, and are stored interleaved in a single stream.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The audio data as a raw string
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object containing the decoded data
    </ol>




</dd>
    <dt>
    <a name = "mdfpwm"></a>
    <strong>mdfpwm (data)</strong>
    </dt>
    <dd>
    Creates a new audio object from MDFPWMv3 data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The audio data as a raw string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object containing the decoded data
    </ol>




</dd>
    <dt>
    <a name = "wav"></a>
    <strong>wav (data)</strong>
    </dt>
    <dd>
    Creates a new audio object from a WAV file.  This accepts PCM files up to 32
 bits, including float data, as well as DFPWM files [as specified here](https://gist.github.com/MCJack123/90c24b64c8e626c7f130b57e9800962c),
 plus IMA and Microsoft ADPCM formats and G.711 u-law/A-law.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The WAV data to load
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the contents of the WAV file
    </ol>




</dd>
    <dt>
    <a name = "aiff"></a>
    <strong>aiff (data)</strong>
    </dt>
    <dd>
    Creates a new audio object from an AIFF or AIFC file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The AIFF data to load
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the contents of the AIFF file
    </ol>




</dd>
    <dt>
    <a name = "au"></a>
    <strong>au (data)</strong>
    </dt>
    <dd>
    Creates a new audio object from an AU file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The AU data to load
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the contents of the AU file
    </ol>




</dd>
    <dt>
    <a name = "flac"></a>
    <strong>flac (data)</strong>
    </dt>
    <dd>
    Creates a new audio object from a FLAC file.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The FLAC data to load
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the contents of the FLAC file
    </ol>




</dd>
    <dt>
    <a name = "new"></a>
    <strong>new (duration, channels, sampleRate)</strong>
    </dt>
    <dd>
    Creates a new empty audio object with the specified duration.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">duration</span>
         number The length of the audio in seconds
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The new empty audio object
    </ol>




</dd>
    <dt>
    <a name = "tone"></a>
    <strong>tone (frequency, duration, amplitude, waveType, duty, channels, sampleRate)</strong>
    </dt>
    <dd>
    Creates a new audio object with a tone of the specified frequency and duration.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">frequency</span>
         number The frequency of the tone in Hertz
        </li>
        <li><span class="parameter">duration</span>
         number The length of the audio in seconds
        </li>
        <li><span class="parameter">amplitude</span>
        ? number The amplitude of the audio from 0.0 to 1.0
        </li>
        <li><span class="parameter">waveType</span>
        ? "sine"|"triangle"|"sawtooth"|"square" The type of wave to generate
        </li>
        <li><span class="parameter">duty</span>
        ? number The duty cycle of the square wave if selected; ignored otherwise
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with the tone
    </ol>




</dd>
    <dt>
    <a name = "noise"></a>
    <strong>noise (duration, amplitude, channels, sampleRate)</strong>
    </dt>
    <dd>
    Creates a new audio object with white noise for the specified duration.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">duration</span>
         number The length of the audio in seconds
        </li>
        <li><span class="parameter">amplitude</span>
        ? number The amplitude of the audio from 0.0 to 1.0
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ A new audio object with noise
    </ol>




</dd>
    <dt>
    <a name = "pack"></a>
    <strong>pack (data, bitDepth, dataType, bigEndian)</strong>
    </dt>
    <dd>
    Packs a table with PCM data into a string using the specified data type.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         number[] The PCM data to pack
        </li>
        <li><span class="parameter">bitDepth</span>
        ? number The bit depth of the audio (8, 16, 24, 32); if `dataType` is "float" then this must be 32
        </li>
        <li><span class="parameter">dataType</span>
        ? "signed"|"unsigned"|"float" The type of each sample
        </li>
        <li><span class="parameter">bigEndian</span>
        ? boolean Whether the data should be big-endian or little-endian
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string _ The packed PCM data
    </ol>




</dd>
    <dt>
    <a name = "play"></a>
    <strong>play (callback, progress, volume, ...)</strong>
    </dt>
    <dd>
    Plays back stream functions created by one of the <a href="index.html#Audio:stream">aukit.stream</a> functions
 or <a href="index.html#Audio:stream">Audio:stream</a>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">callback</span>
         fun():number[][] The iterator function that returns each chunk
        </li>
        <li><span class="parameter">progress</span>
        ? fun(pos:number) A callback to report progress to
 the caller; if omitted then this argument is the first speaker
        </li>
        <li><span class="parameter">volume</span>
        ? number The volume to play the audio at; if omitted then
 this argument is the second speaker (if provided)
        </li>
        <li><span class="parameter">...</span>
         speaker The speakers to play on
        </li>
    </ul>





</dd>
    <dt>
    <a name = "detect"></a>
    <strong>detect (data)</strong>
    </dt>
    <dd>
    Detect the type of audio file from the specified data.  This uses heuristic
 detection methods to attempt to find the correct data type for files without
 headers. It is not recommended to rely on the data type/bit depth reported
 for PCM files - they are merely a suggestion.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string The audio file to check
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
        "pcm"|"dfpwm"|"mdfpwm"|"wav"|"aiff"|"au"|"flac"|nil _ The type of audio file detected, or `nil` if none could be found</li>
        <li>
        number|nil _ The bit depth for PCM data, if the type is "pcm" and the bit depth can be detected</li>
        <li>
        "signed"|"unsigned"|"float"|nil _ The data type for PCM data, if the type is "pcm" and the type can be detected</li>
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="aukit_stream"></a>aukit.stream </h2>

    <dl class="function">
    <dt>
    <a name = "aukit.stream.pcm"></a>
    <strong>aukit.stream.pcm (data, bitDepth, dataType, channels, sampleRate, bigEndian, mono)</strong>
    </dt>
    <dd>
    Returns an iterator to stream raw PCM audio in CC format.  Audio will
 automatically be resampled to 48 kHz, and optionally mixed down to mono. Data
 *must* be interleaved - this will not work with planar audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|table|function The audio data, either as a raw string, a
 table of values (in the format specified by `bitDepth` and `dataType`), or a
 function that returns either of those types. Functions will be called at
 least once before returning to get the type of data to use.
        </li>
        <li><span class="parameter">bitDepth</span>
        ? number The bit depth of the audio (8, 16, 24, 32); if `dataType` is "float" then this must be 32
        </li>
        <li><span class="parameter">dataType</span>
        ? "signed"|"unsigned"|"float" The type of each sample
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">bigEndian</span>
        ? boolean Whether the audio is big-endian or little-endian; ignored if data is a table
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio down to mono
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number _ The total length of the audio in seconds, or the length of
 the first chunk if using a function</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.dfpwm"></a>
    <strong>aukit.stream.dfpwm (data, sampleRate, channels, mono)</strong>
    </dt>
    <dd>
    Returns an iterator to stream audio from DFPWM data.  Audio will automatically
 be resampled to 48 kHz. Multiple channels are expected to be interleaved in
 the encoded DFPWM data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|fun():string The DFPWM data to decode, or a function
 returning chunks to decode
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio down to mono
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number|nil _ The total length of the audio in seconds, or nil if data
 is a function</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.mdfpwm"></a>
    <strong>aukit.stream.mdfpwm (data, mono)</strong>
    </dt>
    <dd>
    Returns an iterator to stream audio from MDFPWMv3 data.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|fun():string The MDFPWM data to decode, or a function
 returning chunks to decode
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio down to mono
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number|nil _ The total length of the audio in seconds, or nil if data
 is a function</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.msadpcm"></a>
    <strong>aukit.stream.msadpcm (input, blockAlign, channels, sampleRate, mono, coefficients)</strong>
    </dt>
    <dd>
    Returns an iterator to stream audio from Microsoft ADPCM data.  Audio will
 automatically be resampled to 48 kHz.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         string|fun():string The audio data as a raw string or
 reader function
        </li>
        <li><span class="parameter">blockAlign</span>
         number The number of bytes in each block
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio down to mono
        </li>
        <li><span class="parameter">coefficients</span>
        ? table Two lists of coefficients to use
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number|nil _ The total length of the audio in seconds, or nil if data
 is a function</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.adpcm"></a>
    <strong>aukit.stream.adpcm (input, blockAlign, channels, sampleRate, mono)</strong>
    </dt>
    <dd>
    Returns an iterator to stream data from IMA ADPCM data.  Audio will
 automatically be resampled to 48 kHz, and mixed to mono if desired. Data
 *must* be in the interleaving format used in WAV files (i.e. periodic blocks
 with 4/8-byte headers, channels alternating every 4 bytes, lower nibble first).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         string|fun():string The audio data as a raw string or
 reader function
        </li>
        <li><span class="parameter">blockAlign</span>
         number The number of bytes in each block
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio down to mono
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number|nil _ The total length of the audio in seconds, or nil if data
 is a function</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.g711"></a>
    <strong>aukit.stream.g711 (input, ulaw, channels, sampleRate, mono)</strong>
    </dt>
    <dd>
    Returns an iterator to stream data from u-law/A-law G.711 data.  Audio will
 automatically be resampled to 48 kHz, and mixed to mono if desired.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         string|fun():string The audio data as a raw string or
 reader function
        </li>
        <li><span class="parameter">ulaw</span>
         boolean Whether the audio uses u-law (true) or A-law (false).
        </li>
        <li><span class="parameter">channels</span>
        ? number The number of channels present in the audio
        </li>
        <li><span class="parameter">sampleRate</span>
        ? number The sample rate of the audio in Hertz
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio down to mono
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number|nil _ The total length of the audio in seconds, or nil if data
 is a function</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.wav"></a>
    <strong>aukit.stream.wav (data, mono, ignoreHeader)</strong>
    </dt>
    <dd>
    Returns an iterator to stream audio from a WAV file.  Audio will automatically
 be resampled to 48 kHz, and optionally mixed down to mono. This accepts PCM
 files up to 32 bits, including float data, as well as DFPWM files [as specified here](https://gist.github.com/MCJack123/90c24b64c8e626c7f130b57e9800962c).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|fun():string The WAV file to decode, or a function
 returning chunks to decode (the first chunk MUST contain the ENTIRE header)
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio to mono
        </li>
        <li><span class="parameter">ignoreHeader</span>
        ? boolean Whether to ignore additional headers
 if they appear later in the audio stream
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number|nil _ The total length of the audio in seconds</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.aiff"></a>
    <strong>aukit.stream.aiff (data, mono, ignoreHeader)</strong>
    </dt>
    <dd>
    Returns an iterator to stream audio from an AIFF or AIFC file.  Audio will
 automatically be resampled to 48 kHz, and optionally mixed down to mono.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|fun():string The AIFF file to decode, or a function
 returning chunks to decode (the first chunk MUST contain the ENTIRE header)
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio to mono
        </li>
        <li><span class="parameter">ignoreHeader</span>
        ? boolean Whether to ignore additional headers
 if they appear later in the audio stream
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number _ The total length of the audio in seconds</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.au"></a>
    <strong>aukit.stream.au (data, mono, ignoreHeader)</strong>
    </dt>
    <dd>
    Returns an iterator to stream data from an AU file.  Audio will automatically
 be resampled to 48 kHz, and optionally mixed down to mono.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|fun():string The AU file to decode, or a function
 returning chunks to decode (the first chunk MUST contain the ENTIRE header)
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio to mono
        </li>
        <li><span class="parameter">ignoreHeader</span>
        ? boolean Whether to ignore additional headers
 if they appear later in the audio stream
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number _ The total length of the audio in seconds</li>
    </ol>




</dd>
    <dt>
    <a name = "aukit.stream.flac"></a>
    <strong>aukit.stream.flac (data, mono)</strong>
    </dt>
    <dd>
    Returns an iterator to stream data from a FLAC file.  Audio will automatically
 be resampled to 48 kHz, and optionally mixed down to mono.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">data</span>
         string|fun():string The FLAC file to decode, or a function
 returning chunks to decode
        </li>
        <li><span class="parameter">mono</span>
        ? boolean Whether to mix the audio to mono
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
         fun():number[][]|nil,number|nil _ An iterator function that returns
 chunks of each channel's data as arrays of signed 8-bit 48kHz PCM, as well as
 the current position of the audio in seconds</li>
        <li>
        number _ The total length of the audio in seconds</li>
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="aukit_effects"></a>aukit.effects </h2>

    <dl class="function">
    <dt>
    <a name = "aukit.effects.amplify"></a>
    <strong>aukit.effects.amplify (audio, multiplier)</strong>
    </dt>
    <dd>
    Amplifies the audio by the multiplier specified.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">multiplier</span>
         number The multiplier to apply
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.speed"></a>
    <strong>aukit.effects.speed (audio, multiplier)</strong>
    </dt>
    <dd>
    Changes the speed and pitch of audio by a multiplier, resampling to keep the
 same sample rate.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">multiplier</span>
         number The multiplier to apply
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.fade"></a>
    <strong>aukit.effects.fade (audio, startTime, startAmplitude, endTime, endAmplitude)</strong>
    </dt>
    <dd>
    Fades a period of music from one amplitude to another.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">startTime</span>
         number The start time of the fade, in seconds
        </li>
        <li><span class="parameter">startAmplitude</span>
         number The amplitude of the beginning of the fade
        </li>
        <li><span class="parameter">endTime</span>
         number The end time of the fade, in seconds
        </li>
        <li><span class="parameter">endAmplitude</span>
         number The amplitude of the end of the fade
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.invert"></a>
    <strong>aukit.effects.invert (audio)</strong>
    </dt>
    <dd>
    Inverts all channels in the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.normalize"></a>
    <strong>aukit.effects.normalize (audio, peakAmplitude, independent)</strong>
    </dt>
    <dd>
    Normalizes audio to the specified peak amplitude.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">peakAmplitude</span>
        ? number The maximum amplitude
        </li>
        <li><span class="parameter">independent</span>
        ? boolean Whether to normalize each channel independently
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.center"></a>
    <strong>aukit.effects.center (audio)</strong>
    </dt>
    <dd>
    Centers the DC offset of each channel.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.trim"></a>
    <strong>aukit.effects.trim (audio, threshold)</strong>
    </dt>
    <dd>
    Trims any extra silence on either end of the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">threshold</span>
        ? number The maximum value to register as silence
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.delay"></a>
    <strong>aukit.effects.delay (audio, delay, multiplier)</strong>
    </dt>
    <dd>
    Adds a delay to the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">delay</span>
         number The amount of time to delay for, in seconds
        </li>
        <li><span class="parameter">multiplier</span>
        ? number The multiplier to apply to the delayed audio
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.echo"></a>
    <strong>aukit.effects.echo (audio, delay, multiplier)</strong>
    </dt>
    <dd>
    Adds an echo to the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">delay</span>
        ? number The amount of time to echo after, in seconds
        </li>
        <li><span class="parameter">multiplier</span>
        ? number The decay multiplier to apply to the echoed audio
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.reverb"></a>
    <strong>aukit.effects.reverb (audio, delay, decay, wetMultiplier, dryMultiplier)</strong>
    </dt>
    <dd>
    Adds reverb to the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">delay</span>
        ? number The amount of time to reverb after, in **milliseconds**
        </li>
        <li><span class="parameter">decay</span>
        ? number The decay factor to use
        </li>
        <li><span class="parameter">wetMultiplier</span>
        ? number The wet (reverbed) mix amount
        </li>
        <li><span class="parameter">dryMultiplier</span>
        ? number The dry (original) mix amount
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.lowpass"></a>
    <strong>aukit.effects.lowpass (audio, frequency)</strong>
    </dt>
    <dd>
    Applies a low-pass filter to the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">frequency</span>
         number The cutoff frequency for the filter
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
    <dt>
    <a name = "aukit.effects.highpass"></a>
    <strong>aukit.effects.highpass (audio, frequency)</strong>
    </dt>
    <dd>
    Applies a high-pass filter to the specified audio.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">audio</span>
         Audio The audio to modify
        </li>
        <li><span class="parameter">frequency</span>
         number The cutoff frequency for the filter
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Audio _ The audio modified
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/lunarmodules/LDoc">LDoc 1.5.0</a></i>
<i style="float:right;">Last updated 2024-02-12 22:08:59 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
